<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vigilance System - Algorithm Visualizations</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dashboard.css') }}">
    <style>
        .visualization-section {
            margin-bottom: 40px;
            background-color: #ffffff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            color: #212529;
        }
        .visualization-section h2 {
            color: #212529;
            border-bottom: 2px solid #212529;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .visualization-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .visualization-item {
            flex: 1;
            min-width: 300px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            background-color: #f8f9fa;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .visualization-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        .visualization-item h3 {
            margin-top: 0;
            color: #212529;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 8px;
        }
        .visualization-item p {
            color: #495057;
        }
        .visualization-item strong {
            color: #000000;
        }
        img.animation, img.explanation {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
            margin: 15px auto;
            border: 1px solid #dee2e6;
        }
        body {
            background-color: #f8f9fa;
            color: #212529;
        }
        .lead {
            color: #495057;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Vigilance System</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('index') }}">Dashboard</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="{{ url_for('visualizations') }}">Algorithm Visualizations</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('network') }}">Network Routing</a>
                    </li>
                </ul>
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="{{ url_for('logout') }}">
                            <i class="bi bi-box-arrow-right"></i> Logout
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-3">
        <div class="row">
            <div class="col-12">
                <h1 class="mb-4" style="text-align: center; margin-top: 20px;">Algorithm Visualizations</h1>
                <div class="visualization-section">
                    <h2>Overview</h2>
                    <p>This page provides detailed explanations of the algorithms used in the Vigilance System for object detection, tracking, and network routing. Each algorithm is described with its working principles, time complexity, advantages, and limitations.</p>
                </div>

                <div class="visualization-section">
                    <h2>Object Tracking Algorithms</h2>
                    <p>The system supports multiple object tracking algorithms to associate detections across frames.</p>
                    <div class="visualization-container">
                        <div class="visualization-item">
                            <h3>KNN Tracker</h3>
                            <p><strong>How it works:</strong> Uses K-Nearest Neighbors to match new detections to existing tracked objects based on spatial proximity.</p>
                            <p><strong>Time Complexity:</strong> O(n log n) where n is the number of tracked objects.</p>
                            <p><strong>Advantages:</strong> Works well with consistent motion patterns, adapts to different object speeds.</p>
                            <img src="{{ url_for('static', filename='visualizations/object_tracking.gif') }}" alt="KNN Tracking Animation" class="animation">
                        </div>
                        <div class="visualization-item">
                            <h3>SVM Tracker</h3>
                            <p><strong>How it works:</strong> Uses Support Vector Machines to classify new detections and match them to existing tracked objects.</p>
                            <p><strong>Time Complexity:</strong> O(nÂ²) for training, O(n) for prediction, where n is the number of support vectors.</p>
                            <p><strong>Advantages:</strong> Better handling of occlusions and complex motion patterns.</p>
                        </div>
                        <div class="visualization-item">
                            <h3>Naive Bayes Tracker</h3>
                            <p><strong>How it works:</strong> Uses Naive Bayes classifier to probabilistically match new detections to existing tracked objects.</p>
                            <p><strong>Time Complexity:</strong> O(n) for both training and prediction, where n is the number of features.</p>
                            <p><strong>Advantages:</strong> Fast and works well with limited training data.</p>
                        </div>
                    </div>
                </div>

                <div class="visualization-section">
                    <h2>Object Detection Algorithms</h2>
                    <p>The system supports multiple object detection algorithms to identify objects in video frames.</p>
                    <div class="visualization-container">
                        <div class="visualization-item">
                            <h3>Background Subtraction</h3>
                            <p><strong>How it works:</strong> Builds a statistical model of the background and identifies moving objects as foreground.</p>
                            <p><strong>Time Complexity:</strong> O(n) where n is the number of pixels in the frame.</p>
                            <p><strong>Advantages:</strong> Fast and works well for static cameras with relatively static backgrounds.</p>
                            <p><strong>Limitations:</strong> Sensitive to lighting changes and camera movement.</p>
                        </div>
                        <div class="visualization-item">
                            <h3>HOG+SVM</h3>
                            <p><strong>How it works:</strong> Extracts Histogram of Oriented Gradients features and uses a Support Vector Machine classifier to detect people.</p>
                            <p><strong>Time Complexity:</strong> O(n) where n is the number of detection windows.</p>
                            <p><strong>Advantages:</strong> Good at detecting people, doesn't require background modeling.</p>
                            <p><strong>Limitations:</strong> Slower than background subtraction, primarily designed for pedestrian detection.</p>
                        </div>
                        <div class="visualization-item">
                            <h3>YOLO (You Only Look Once)</h3>
                            <p><strong>How it works:</strong> Single-shot object detection using convolutional neural networks to predict bounding boxes and class probabilities.</p>
                            <p><strong>Time Complexity:</strong> O(1) with respect to the number of objects (constant time).</p>
                            <p><strong>Advantages:</strong> Fast, accurate, and can detect multiple object classes simultaneously.</p>
                            <p><strong>Limitations:</strong> Requires more computational resources than traditional methods.</p>
                        </div>
                    </div>
                </div>

                <div class="visualization-section">
                    <h2>Decision Making Algorithms</h2>
                    <p>The decision making algorithms include loitering detection and crowd detection.</p>
                    <div class="visualization-container">
                        <div class="visualization-item">
                            <h3>Animation</h3>
                            <img src="{{ url_for('static', filename='visualizations/decision_making.gif') }}" alt="Decision Making Animation" class="animation">
                        </div>
                        <div class="visualization-item">
                            <h3>Loitering Detection Explanation</h3>
                            <img src="{{ url_for('static', filename='visualizations/loitering_detection_explanation.png') }}" alt="Loitering Detection Explanation" class="explanation">
                        </div>
                        <div class="visualization-item">
                            <h3>Crowd Detection Explanation</h3>
                            <img src="{{ url_for('static', filename='visualizations/crowd_detection_explanation.png') }}" alt="Crowd Detection Explanation" class="explanation">
                        </div>
                    </div>
                </div>

                <div class="visualization-section">
                    <h2>Network Routing Algorithms</h2>
                    <p>The system supports multiple network routing algorithms to distribute video processing across nodes.</p>
                    <div class="visualization-container">
                        <div class="visualization-item">
                            <h3>Direct Connection</h3>
                            <p><strong>How it works:</strong> All traffic goes to a single node.</p>
                            <p><strong>Time Complexity:</strong> O(1) - constant time routing decision.</p>
                            <p><strong>Advantages:</strong> Simple implementation, no routing overhead.</p>
                            <p><strong>Limitations:</strong> Not scalable, single point of failure.</p>
                        </div>
                        <div class="visualization-item">
                            <h3>Round Robin</h3>
                            <p><strong>How it works:</strong> Distributes traffic evenly across all nodes in sequence.</p>
                            <p><strong>Time Complexity:</strong> O(1) - constant time routing decision.</p>
                            <p><strong>Advantages:</strong> Simple load balancing, fair distribution.</p>
                            <p><strong>Limitations:</strong> Doesn't consider node capacity or current load.</p>
                        </div>
                        <div class="visualization-item">
                            <h3>Least Connection</h3>
                            <p><strong>How it works:</strong> Sends traffic to the node with the fewest active connections.</p>
                            <p><strong>Time Complexity:</strong> O(n) where n is the number of nodes.</p>
                            <p><strong>Advantages:</strong> Adaptive to changing loads, prevents overloading.</p>
                            <p><strong>Limitations:</strong> Requires tracking connection counts, slightly higher overhead.</p>
                        </div>
                        <div class="visualization-item">
                            <h3>Weighted</h3>
                            <p><strong>How it works:</strong> Routes based on node capacity weights, sending more traffic to higher capacity nodes.</p>
                            <p><strong>Time Complexity:</strong> O(n) where n is the number of nodes.</p>
                            <p><strong>Advantages:</strong> Accounts for heterogeneous node capabilities.</p>
                            <p><strong>Limitations:</strong> Requires manual configuration of weights.</p>
                        </div>
                    </div>
                </div>

                <div class="visualization-section">
                    <h2>Implementation Notes</h2>
                    <p>All algorithms have been implemented with careful consideration of performance and accuracy. The system allows switching between algorithms to compare their effectiveness in different scenarios.</p>
                    <div class="visualization-container">
                        <div class="visualization-item">
                            <h3>Performance Considerations</h3>
                            <p>When selecting algorithms for your use case, consider these factors:</p>
                            <ul>
                                <li><strong>Processing Speed</strong>: Background Subtraction and KNN are faster but less accurate</li>
                                <li><strong>Accuracy</strong>: SVM and Naive Bayes provide better tracking accuracy but require more processing</li>
                                <li><strong>Network Load</strong>: Weighted and Least Connection routing provide better load distribution</li>
                                <li><strong>System Resources</strong>: Consider available CPU/GPU resources when selecting algorithms</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script>
        // Add animation to visualization items
        document.addEventListener('DOMContentLoaded', function() {
            // Animate visualization items on scroll
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('show');
                    }
                });
            }, { threshold: 0.1 });

            document.querySelectorAll('.visualization-item').forEach(item => {
                item.style.opacity = '0';
                item.style.transform = 'translateY(20px)';
                item.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                observer.observe(item);
            });

            // Add CSS for animation
            const style = document.createElement('style');
            style.textContent = `
                .visualization-item.show {
                    opacity: 1 !important;
                    transform: translateY(0) !important;
                }
            `;
            document.head.appendChild(style);

            // Create algorithm complexity chart
            const complexityCtx = document.createElement('canvas');
            complexityCtx.id = 'complexityChart';
            complexityCtx.height = 250;

            // Find the implementation notes section to append the chart
            const implementationSection = document.querySelector('.visualization-section:last-child');
            const chartContainer = document.createElement('div');
            chartContainer.className = 'visualization-item';
            chartContainer.innerHTML = '<h3>Algorithm Complexity Comparison</h3>';
            chartContainer.appendChild(complexityCtx);

            // Add the chart to the implementation section
            if (implementationSection) {
                implementationSection.querySelector('.visualization-container').appendChild(chartContainer);
            }

            // Create the chart
            new Chart(complexityCtx, {
                type: 'bar',
                data: {
                    labels: ['Background Subtraction', 'HOG+SVM', 'YOLO', 'KNN Tracker', 'SVM Tracker', 'Naive Bayes'],
                    datasets: [{
                        label: 'Relative Computational Complexity',
                        data: [10, 40, 70, 30, 60, 20],
                        backgroundColor: [
                            'rgba(54, 162, 235, 0.5)',
                            'rgba(255, 99, 132, 0.5)',
                            'rgba(255, 206, 86, 0.5)',
                            'rgba(75, 192, 192, 0.5)',
                            'rgba(153, 102, 255, 0.5)',
                            'rgba(255, 159, 64, 0.5)'
                        ],
                        borderColor: [
                            'rgba(54, 162, 235, 1)',
                            'rgba(255, 99, 132, 1)',
                            'rgba(255, 206, 86, 1)',
                            'rgba(75, 192, 192, 1)',
                            'rgba(153, 102, 255, 1)',
                            'rgba(255, 159, 64, 1)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Complexity (Higher = More Complex)'
                            }
                        }
                    }
                }
            });
        });
    </script>
</body>
</html>
